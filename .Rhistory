friedmanTestBMR(BMR)
friedmanPostHocTestBMR(BMR)
install.packages("PMCMR")
friedmanPostHocTestBMR(BMR)
g <- generateCritDifferencesData(BMR)
friedmanTestBMR(BMR)
mode(c(1,2,3,2,33))
modeest::mode(c(1,2,3,2,33))
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain")) %>%
select(c("max.number.of.layers", "hidden", "learningrate", "batchsize", "momentum", "visible_dropout"))
TunePlotANN <- ggplot(melt(tune_results_ANN) %>% mutate(value = as.factor(value)), aes(x = value, fill = variable, color = variable)) +
geom_bar(aes(group = task.id)) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
TunePlotANN
tune_results_ANN
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain")) %>%
select(c("task.id", "max.number.of.layers", "hidden", "learningrate", "batchsize", "momentum", "visible_dropout"))
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = task.id) %>% mutate(value = as.factor(value)), aes(x = value, fill = variable, color = variable)) +
geom_bar(aes(group = task.id)) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain"))
names(tune_results_ANN)
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain")) %>%
select(c("task.id", "max.number.of.layers", "hidden", "learningrate", "batchsize", "momentum", "visible_dropout"))
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = variable, color = variable)) +
geom_bar(aes(group = task.id)) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
tune_results_ANN
TunePlotANN
head(TunePlotANN)
head(tune_results_ANN)
head(melt(tune_results_ANN, id.vars = "task.id"))
ggplot(melt(tune_results_ANN, id.vars = "task.id"), aes(x = value, fill = variable, color = variable)) +
geom_bar(aes(group = task.id))
ggplot(melt(tune_results_ANN, id.vars = "task.id"), aes(x = value, fill = variable, color = variable)) +
geom_bar(aes(group = task.id)) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
ggplot(melt(tune_results_ANN, id.vars = "task.id"), aes(x = value, fill = task.id, color = task.id)) +
geom_bar() +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
ggplot(melt(tune_results_ANN, id.vars = "task.id"), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(stat="identity", position=position_dodge()) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
ggplot(melt(tune_results_ANN, id.vars = "task.id"), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge()) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge()) +
ggpubr::theme_pubr() +
facet_wrap(~ variable, scales = "free_x")
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge()) +
ggpubr::theme_pubr() +
labs(x = "")
facet_wrap(~ variable, scales = "free_x")
ggplotly(TunePlotANN)
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge()) +
ggpubr::theme_pubr() +
labs(x = "") +
facet_wrap(~ variable, scales = "free_x")
ggplotly(TunePlotANN)
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain")) %>%
select(c("task.id", "max.number.of.layers", "hidden", "learningrate", "batchsize", "momentum", "visible_dropout"))
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge()) +
ggpubr::theme_pubr() +
labs(x = "") +
facet_wrap(~ variable, scales = "free_x")
ggplotly(TunePlotANN, tooltip = c("value", "count"))
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge2()) +
ggpubr::theme_pubr() +
labs(x = "") +
facet_wrap(~ variable, scales = "free_x")
ggplotly(TunePlotANN, tooltip = c("value", "count"))
dim(tune_results_ANN)
5*100
names(tune_results_ANN)
tune_results_ANN %>% filter(task.id == "SFE")
dim(tune_results_ANN %>% filter(task.id == "SFE"))
tune_results_ANN <- getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain"))
dim(tune_results_ANN)
names(tune_results_ANN)
table(tune_results_ANN$iter)
head(tune_results_ANN)
head(getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain", "svm")))
tune_results_ANN <- unique(getBMRTuneResults(BMR, as.df = T, learner.ids = c("nnTrain"))) %>%
select(c("task.id", "max.number.of.layers", "hidden", "learningrate", "batchsize", "momentum", "visible_dropout"))
TunePlotANN <- ggplot(melt(tune_results_ANN, id.vars = "task.id") %>% mutate(value = as.factor(value)), aes(x = value, fill = task.id, color = task.id)) +
geom_bar(position=position_dodge2()) +
ggpubr::theme_pubr() +
labs(x = "") +
facet_wrap(~ variable, scales = "free_x")
ggplotly(TunePlotANN, tooltip = c("value", "count"))
library("tmaptools")
tmaptools::palette_explorer()
get_brewer_pal("Blues", n = 7, contrast = c(0.4, 1))
l<-get_brewer_pal("Blues", n = 7, contrast = c(0.4, 1))
l
tmaptools::palette_explorer()
require("knitr")
opts_knit$set(root.dir = "~/research/exploitation/R/classification")
opts_chunk$set(echo=FALSE, warning = FALSE, message = FALSE)
library("dplyr")
library("reshape2")
library("ggplot2")
library("philentropy")
library("abind")
library("factoextra")
library("oce")
library("plotly")
library("latex2exp")
library("ggdark")
library("tmap")
library("OpenStreetMap")
library("colorspace")
library("leaflet")
library("scales")
import::here(.from = "./R/utils/lib_classification.R",
get_HG_aes)
import::here(.from = "./R/utils/lib_regional_comparison.R",
make_model_building,
range01,
get_field_data_df,
pfun,
get_lp_dist,
BMRViz,
MostCommonHyperpar,
BMRTuneViz,
get_BMR,
get_lrnH,
get_TunePlotANN,
get_p_lrnH,
get_agg_metrics,
get_ML_performance,
get_Y2_region_data,
get_drivers,
ML_perf_drivers_scatterplot,
make_corr_plot,
get_p_res,
layout_ggplotly
)
regional_map <- readRDS("regional_map.Rds")
regional_map
autocorr <- readRDS("./autocorr.Rds")
p <- ggplot(autocorr$g, aes(x = r, color = region)) +
geom_line(aes(y = trans)) +
geom_hline(yintercept = 1) +
scale_x_log10(
breaks = trans_breaks(n=3, 'log10', function(x) 10^x),
labels = trans_format('log10', math_format(10^.x))
) +
ylim(0, 20) +
labs(x = "radius (m)", y = "pairwise correlation function") +
ggpubr::theme_pubr()
p
l <- get_field_data_df()
field_data_df <- l$field_data_df
mut_keep <- l$mut_keep
sreg <- sort(unique(field_data_df$region))
density_plots <- group_map(field_data_df, ~ pfun(., plot = T))
lp_dist <- get_lp_dist(field_data_df, sreg)
i <- 1
ggplotly(lp_dist[[i]]$p)
ggplotly(density_plots[[i]], tooltip = c("value", "scaled", "ward.grp")) %>% layout_ggplotly(x = -0.05, y = 0)
i <- 6
ggplotly(lp_dist[[i]]$p)
sreg
get_field_data_df <- function(){
csv.dir <- "./data/classified_reach_scale_sites/"
lf <- list.files(file.path(csv.dir), pattern = ".csv", full.names = TRUE)
.lf <- list.files(file.path(csv.dir), pattern = ".csv", full.names = FALSE)
.lf <- unname(sapply(.lf, function(f) unlist(strsplit(f, "_"))[[1]]))
lf <- lf[order(.lf)]
reg <- c("NCC", "NC", "SAC", "SFE", "SC", "SJT", "K") %>% sort()
ind <- sapply(lf, function(f) any(sapply(reg, function(r) grepl(paste0("/",r, "_"), f, fixed = TRUE))))
ldf <- lapply(lf[ind], read.csv)
tab <- table(unlist(lapply(ldf, names)))
keep <- c(names(tab)[tab == length(reg)], "region")
ldf <- lapply(seq_along(ldf), function(i) mutate(ldf[[i]], region = reg[i], ward.grp = paste0(reg[i], ifelse(ward.grp < 10, "0", ""), ward.grp)) %>% select(keep))
field_data_df <- do.call(rbind, ldf) %>% select(-c("Ac", "slope", "vc.dist"))
mut_keep <- colnames(field_data_df)[!colnames(field_data_df) %in% c("ward.grp", "region")]
field_data_df <- group_by(field_data_df, region) %>% mutate_at(mut_keep, range01)
return(list(field_data_df = field_data_df,mut_keep = mut_keep))
}
l <- get_field_data_df()
field_data_df <- l$field_data_df
mut_keep <- l$mut_keep
sreg <- sort(unique(field_data_df$region))
density_plots <- group_map(field_data_df, ~ pfun(., plot = T))
lp_dist <- get_lp_dist(field_data_df, sreg)
sreg
field_data_df
l <- get_field_data_df()
field_data_df <- l$field_data_df
mut_keep <- l$mut_keep
sreg <- sort(unique(field_data_df$region))
density_plots <- group_map(field_data_df, ~ pfun(., plot = T))
lp_dist <- get_lp_dist(field_data_df, sreg)
length(density_plots)
density_plots[[1]]
density_plots[[2]]
density_plots[[3]]
density_plots[[5]]
density_plots[[5]]
density_plots[[4]]
density_plots[[6]]
density_plots[[7]]
l <- get_field_data_df()
field_data_df <- l$field_data_df
mut_keep <- l$mut_keep
sreg <- sort(unique(field_data_df$region))
density_plots <- group_map(field_data_df, ~ pfun(., plot = T))
lp_dist <- get_lp_dist(field_data_df, sreg)
density_plots[[1]]
density_plots[[7]]
l <- get_field_data_df()
field_data_df <- l$field_data_df
mut_keep <- l$mut_keep
sreg <- sort(unique(field_data_df$region))
density_plots <- group_map(field_data_df, ~ pfun(., plot = T))
lp_dist <- get_lp_dist(field_data_df, sreg)
i <- 1
ggplotly(lp_dist[[i]]$p)
ggplotly(density_plots[[i]], tooltip = c("value", "scaled", "ward.grp")) %>% layout_ggplotly(x = -0.05, y = 0)
require("knitr")
opts_knit$set(root.dir = "~/research/exploitation/R/classification")
opts_chunk$set(echo=FALSE, warning = FALSE, message = FALSE)
library("dplyr")
library("reshape2")
library("ggplot2")
library("philentropy")
library("abind")
library("factoextra")
library("oce")
library("plotly")
library("latex2exp")
library("ggdark")
library("tmap")
library("OpenStreetMap")
library("colorspace")
library("leaflet")
library("scales")
import::here(.from = "./R/utils/lib_classification.R",
get_HG_labels)
import::here(.from = "./R/utils/lib_regional_comparison.R",
make_model_building,
range01,
get_field_data_df,
pfun,
get_lp_dist,
BMRViz,
MostCommonHyperpar,
BMRTuneViz,
get_BMR,
get_lrnH,
get_TunePlotANN,
get_p_lrnH,
get_agg_metrics,
get_ML_performance,
get_Y2_region_data,
get_drivers,
ML_perf_drivers_scatterplot,
make_corr_plot,
get_p_res,
layout_ggplotly,
get_median_table,
get_HG_colors,
get_HG_aes,
range01
)
prediction_map <- readRDS("prediction_map.Rds")
prediction_map
tmap_mode("view")
prediction_map
setwd("/media/hguillon/hrvg/research/exploitation/R/latin_america")
library("Amelia")
library("circlize")
library("clValid")
library("corrplot")
library("cowplot")
library("factoextra")
library("forcats")
library("ggplot2")
library("reshape2")
library("ggsci")
library("Hmisc")
library("mlr")
library("oce")
library("raster")
library("RColorBrewer")
library("tmap")
library("dplyr")
library("import")
library("ggpubr")
library("plotly")
### functions ###
import::here(.from = "./R/network_analysis/lib_network_analysis.R",
get_network,
VizSpots)
m <- get_network(type = "NSF_specific", prob = TRUE, filter_method = FALSE, blindspot = FALSE, country.threshold = 30, percentile.threshold = 0.90, country_filter = FALSE, countries = NULL, theme_filter = FALSE, themes = NULL))
m <- get_network(type = "NSF_specific", prob = TRUE, filter_method = FALSE, blindspot = FALSE, country.threshold = 30, percentile.threshold = 0.90, country_filter = FALSE, countries = NULL, theme_filter = FALSE, themes = NULL)
m
VizSpots <- function(m, scaled = FALSE, cluster_color = TRUE, NSF_general_color = TRUE, type = "theme", sort_topic = TRUE){
countryColors <- readRDS("countryColors.Rds")
N <- nrow(countryColors)
ind <- match(rownames(m), countryColors$country_name)
countryColors <- as.matrix(countryColors[ind, 1:3])
if (cluster_color){
l_phcs <- readRDS("./data/l_phcs.Rds")
cluster_descriptors <- ggplot_build(l_phcs[[1]][[3]])$data[[2]][, c("label", "group", "colour")]
cluster_descriptors <- cluster_descriptors[which(cluster_descriptors$label %in% rownames(m)), ]
cluster_descriptors <- cluster_descriptors[order(as.character(cluster_descriptors$label), decreasing = TRUE), ]
}
if (NSF_general_color & type == "NSF_specific"){
topic_names <- read.csv("./data/topic_names.csv")
lvls <- as.numeric(topic_names$NSF_general[match(colnames(m), topic_names$NSF_specific)])
if (sort_topic){
m <- m[, order(lvls)]
lvls <- as.numeric(topic_names$NSF_general[match(colnames(m), topic_names$NSF_specific)])
}
NSF_general_colors <- RColorBrewer::brewer.pal(5, "Set1")[lvls]
}
grid.col <- rainbow(N)[ind]
grid.col <- c(grid.col, rep("#c2c2c2", ncol(m)))
circos.clear()
par(mar = rep(0, 4), cex=.75)
circos.par(start.degree = -90)
chordDiagram(x = m, directional = 1,
transparency = 0.3,
grid.col = grid.col,
link.sort = TRUE,
link.decreasing = TRUE,
symmetric = FALSE,
diffHeight = 0,
scale = scaled,
annotationTrack = NULL,
preAllocateTracks = list(
list(track.height = 0.03, track.margin = c(0, 0)),
list(track.height = circos.par("track.height")),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0))
),
big.gap = 45)
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
# circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
text(coor[1, 1], coor[1, 2], sector.name)
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 1)
}, bg.border = NA)
for (i in seq(nrow(m))){
highlight.sector(rownames(m)[i], track.index = 3, col = countryColors[i, 1])
highlight.sector(rownames(m)[i], track.index = 4, col = countryColors[i, 2])
highlight.sector(rownames(m)[i], track.index = 5, col = countryColors[i, 3])
if (cluster_color) highlight.sector(rownames(m)[i], track.index = 1, col = cluster_descriptors$colour[i])
}
if (NSF_general_color & type == "NSF_specific"){
for (i in seq(ncol(m))){
highlight.sector(colnames(m)[i], track.index = 3, col = NSF_general_colors[i])
highlight.sector(colnames(m)[i], track.index = 4, col = NSF_general_colors[i])
highlight.sector(colnames(m)[i], track.index = 5, col = NSF_general_colors[i])
}
} else {
for (i in seq(ncol(m))){
highlight.sector(colnames(m)[i], track.index = 3, col = "#c2c2c2")
highlight.sector(colnames(m)[i], track.index = 4, col = "#c2c2c2")
highlight.sector(colnames(m)[i], track.index = 5, col = "#c2c2c2")
}
}
}
VizSpots(m, type = "NSF_specific")
scaled = FALSE; cluster_color = TRUE; NSF_general_color = TRUE; type = "NSF_specific"; sort_topic = TRUE
countryColors <- readRDS("countryColors.Rds")
N <- nrow(countryColors)
ind <- match(rownames(m), countryColors$country_name)
countryColors <- as.matrix(countryColors[ind, 1:3])
if (cluster_color){
l_phcs <- readRDS("./data/l_phcs.Rds")
cluster_descriptors <- ggplot_build(l_phcs[[1]][[3]])$data[[2]][, c("label", "group", "colour")]
cluster_descriptors <- cluster_descriptors[which(cluster_descriptors$label %in% rownames(m)), ]
cluster_descriptors <- cluster_descriptors[order(as.character(cluster_descriptors$label), decreasing = TRUE), ]
}
if (NSF_general_color & type == "NSF_specific"){
topic_names <- read.csv("./data/topic_names.csv")
lvls <- as.numeric(topic_names$NSF_general[match(colnames(m), topic_names$NSF_specific)])
if (sort_topic){
m <- m[, order(lvls)]
lvls <- as.numeric(topic_names$NSF_general[match(colnames(m), topic_names$NSF_specific)])
}
NSF_general_colors <- RColorBrewer::brewer.pal(5, "Set1")[lvls]
}
grid.col <- rainbow(N)[ind]
grid.col <- c(grid.col, rep("#c2c2c2", ncol(m)))
circos.clear()
par(mar = rep(0, 4), cex=.75)
circos.par(start.degree = -90)
chordDiagram(x = m, directional = 1,
transparency = 0.3,
grid.col = grid.col,
link.sort = TRUE,
link.decreasing = TRUE,
symmetric = FALSE,
diffHeight = 0,
scale = scaled,
annotationTrack = NULL,
preAllocateTracks = list(
list(track.height = 0.03, track.margin = c(0, 0)),
list(track.height = circos.par("track.height")),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0))
),
big.gap = 45)
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
# circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
coor = circlize:::polar2Cartesian(circlize(mean(xlim), ylim[1] + .1))
text(coor[1, 1], coor[1, 2], sector.name)
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 1)
}, bg.border = NA)
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
# circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
coor = circlize:::polar2Cartesian(circlize(mean(xlim), ylim[1] + .1))
text(coor[1, 1], coor[1, 2], sector.name)
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 1)
}, bg.border = NA)
grid.col <- rainbow(N)[ind]
grid.col <- c(grid.col, rep("#c2c2c2", ncol(m)))
circos.clear()
par(mar = rep(0, 4), cex=.75)
circos.par(start.degree = -90)
chordDiagram(x = m, directional = 1,
transparency = 0.3,
grid.col = grid.col,
link.sort = TRUE,
link.decreasing = TRUE,
symmetric = FALSE,
diffHeight = 0,
scale = scaled,
annotationTrack = NULL,
preAllocateTracks = list(
list(track.height = 0.03, track.margin = c(0, 0)),
list(track.height = circos.par("track.height")),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0))
),
big.gap = 45)
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
# circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5))
# coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
coor = circlize:::polar2Cartesian(circlize(mean(xlim), ylim[1] + .1))
text(coor[1, 1], coor[1, 2], sector.name)
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 1)
}, bg.border = NA)
grid.col <- rainbow(N)[ind]
grid.col <- c(grid.col, rep("#c2c2c2", ncol(m)))
circos.clear()
par(mar = rep(0, 4), cex=.75)
circos.par(start.degree = -90)
chordDiagram(x = m, directional = 1,
transparency = 0.3,
grid.col = grid.col,
link.sort = TRUE,
link.decreasing = TRUE,
symmetric = FALSE,
diffHeight = 0,
scale = scaled,
annotationTrack = NULL,
preAllocateTracks = list(
list(track.height = 0.03, track.margin = c(0, 0)),
list(track.height = circos.par("track.height")),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0)),
list(track.height = 0.02, track.margin = c(0, 0))
),
big.gap = 45)
circos.trackPlotRegion(track.index = 2, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .1, sector.name, facing = "downward", niceFacing = TRUE, adj = c(0, 0.5))
coor = circlize:::polar2Cartesian(circlize(mean(xlim), mean(ylim)))
# circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 1)
}, bg.border = NA)
